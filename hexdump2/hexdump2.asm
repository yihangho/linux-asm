section .bss
	BUFFLEN equ 10
	Buff resb BUFFLEN

section .data
	DumpLin: db " 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 "
	DUMPLEN  equ $-DumpLin
	ASCLin:  db "|................|", 10
	ASCLEN   equ $-ASCLin
	FULLLEN  equ $-DumpLin

	HexDigits: db "0123456789ABCDEF"

	DotXlat:
		db 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E
		db 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E
		db 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F
		db 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F
		db 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F
		db 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F
		db 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F
		db 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x2E
		db 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E
		db 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E
		db 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E
		db 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E
		db "0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E"
		db "0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E"
		db "0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E"
		db "0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E"
	
section .text

ClearLine:
	pushad
	mov edx, 15
.poke:
	mov eax, 0
	call DumpChar
	sub edx, 1
	jae .poke
	popad
	ret

DumpChar:
	push ebx
	push ecx
	
	mov bl, byte[DotXlat+eax]
	mov byte[ASCLin+edx+1], bl

	and eax, 0xFF
	mov ebx, eax
	lea ecx, [edx*2+edx]

	and eax, 0xF
	mov al, byte[HexDigits+eax]
	mov byte[DumpLin+ecx+2], al

	shr ebx, 4
	mov bl, byte[HexDigits+ebx]
	mov byte[DumpLin+ecx+1], bl

	pop ecx
	pop ebx
	ret

PrintLine:
	pushad
	mov eax, 4
	mov ebx, 1
	mov ecx, DumpLin
	mov edx, FULLLEN
	int 0x80
	popad
	ret

LoadBuffer:
	push eax
	push ebx
	push edx
	mov eax, 3
	mov ebx, 0
	mov ecx, Buff
	mov edx, BUFFLEN
	int 0x80
	xor ecx, ecx
	mov ebp, eax
	pop edx
	pop ebx
	pop eax
	ret

global _start
_start:
	xor esi, esi ; esi will be used to record the total number of bytes processed
	call LoadBuffer
	cmp ebp, 0
	je Exit

Scan:
	; ecx is the counter of the current chunk
	; it is used to loop through the entire buffer
	; esi is used to control which bytes to write to in DumpLin and ASCLin
	xor eax, eax
	mov al, byte[Buff+ecx]
	mov edx, esi
	and edx, 0xF
	call DumpChar

	; increases the counter
	inc esi
	inc ecx
	cmp ecx, ebp
	jb .modTest ; modTest is used to test if esi is a multiple of 16 - if so, printline
	call LoadBuffer
	cmp ebp, 0
	je Done
.modTest:
	; esi is a multiple of 16 if its last 4 bits are 0 (16 = 0b1000, 0xF = 0b1111)
	test esi, 0xF
	jnz Scan ; not a multiple of 16
	call PrintLine
	call ClearLine
	jmp Scan

Done:
	call PrintLine
Exit:
	mov eax, 1
	mov ebx, 0
	int 0x80
